<!-- Generated by SpecStory -->

# Fixing Failing Tests in test_rooms.py (2025-04-22 22:37:44)

_**User**_

lets try and fix the failing tests in @test_rooms.py 

follow the solution and analysis

make sure to run the pytests after sourcing the venv

---

_**Assistant**_

I'll help you fix the failing tests in `test_rooms.py`. According to the FAILING_TESTS.md analysis, the main issue is with the `test_room_cleanup` test failing due to database initialization problems. Let's implement the solution step by step.

First, let's check the current test file structure and then make the necessary changes.


---

Read file: app/tests/test_rooms.py

---

Let's first check if we have a conftest.py file where we can add our database fixtures:


---

Read file: app/tests/conftest.py

---

Great! I see we already have a good test setup in conftest.py with proper database fixtures. The issue with the failing test is likely due to a few things:

1. The test is using `datetime.utcnow()` which is deprecated
2. We need to ensure the Redis service mock is properly set up
3. We need to make sure the cleanup task is properly imported and configured

Let's modify the test_rooms.py file to fix these issues:



---

Cancelled

---

Now let's check the cleanup_inactive_rooms function to make sure it's properly implemented:



---

Read file: app/core/tasks.py

---

I see we need to update the tasks.py file as well to use the correct datetime import and UTC timezone. Let's fix that:




---

Cancelled

---

Now let's run the tests to see if our changes fixed the issues. I'll propose the command to run the tests:




---

```bash
source venv/bin/activate && pytest app/tests/test_rooms.py -v
```

```
.venvshared_whiteboard_backend [main●●] % source venv/bin/activate && pytest app/tests/test_roo
ms.py -v                   source venv/bin/activate && pytest app/tests/test_rooms.py -v
source: no such file or directory: venv/bin/activate
.venvshared_whiteboard_backend [main●●] %
```

---

I see the issue - the virtual environment path is incorrect. Let's try with the correct path:



---

```bash
source .venv/bin/activate && pytest app/tests/test_rooms.py -v
```

```
===================================== test session starts =====================================
platform linux -- Python 3.13.2, pytest-8.0.2, pluggy-1.5.0 -- /home/db/code/shared_whiteboard_
backend/.venv/bin/python3
cachedir: .pytest_cache
rootdir: /home/db/code/shared_whiteboard_backend
configfile: pyproject.toml
plugins: anyio-4.9.0, cov-4.1.0, asyncio-0.23.5
asyncio: mode=Mode.STRICT
collected 5 items                                                                             

app/tests/test_rooms.py::test_create_room PASSED                                        [ 20%]
app/tests/test_rooms.py::test_get_room PASSED                                           [ 40%]
app/tests/test_rooms.py::test_get_nonexistent_room PASSED                               [ 60%]
app/tests/test_rooms.py::test_room_limit_per_ip PASSED                                  [ 80%]
app/tests/test_rooms.py::test_room_cleanup FAILED                                       [100%]

========================================== FAILURES ===========================================
______________________________________ test_room_cleanup ______________________________________

self = <sqlalchemy.engine.base.Connection object at 0x79005b5bca10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x79005c4492b0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x79005b565ef0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x79005b6c5cd0>
parameters = [('2025-04-23 05:35:02.018027', 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x79005c4492b0>
cursor = <sqlite3.Cursor object at 0x79005b5b2cc0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count = ?'
parameters = ('2025-04-23 05:35:02.018027', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x79005b565ef0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: room

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x79005b6c7230>
session = <sqlmodel.orm.session.Session object at 0x79005b6c7490>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x79005b53a6c0>

    @pytest.mark.asyncio
    async def test_room_cleanup(client: TestClient, session, mock_redis_service):
        """Test room cleanup for inactive rooms"""
        # Create a room
        response = client.post("/api/v1/rooms")
        room_id = response.json()["id"]
    
        # Get the room and modify its last_activity to be old
        room = session.get(Room, room_id)
        room.last_activity = datetime.now(UTC) - timedelta(minutes=10)
        session.add(room)
        session.commit()
    
        # Import and run cleanup
        from app.core.tasks import cleanup_inactive_rooms
>       await cleanup_inactive_rooms()

app/tests/test_rooms.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
app/core/tasks.py:19: in cleanup_inactive_rooms
    inactive_rooms = session.exec(
.venv/lib/python3.13/site-packages/sqlmodel/orm/session.py:66: in exec
    results = super().execute(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x79005c4492b0>
cursor = <sqlite3.Cursor object at 0x79005b5b2cc0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count = ?'
parameters = ('2025-04-23 05:35:02.018027', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x79005b565ef0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: room
E       [SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active
_user_count
E       FROM room 
E       WHERE room.last_activity < ? AND room.active_user_count = ?]
E       [parameters: ('2025-04-23 05:35:02.018027', 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: OperationalError
------------------------------------ Captured stderr call -------------------------------------
2025-04-22 22:40:02,018 - app.core.tasks - ERROR - Error in cleanup_inactive_rooms: (sqlite3.Op
erationalError) no such table: room
[SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_user_co
unt
FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:35:02.018027', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
-------------------------------------- Captured log call --------------------------------------
ERROR    app.core.tasks:tasks.py:37 Error in cleanup_inactive_rooms: (sqlite3.OperationalError)
 no such table: room
[SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_user_co
unt
FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:35:02.018027', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
====================================== warnings summary =======================================
.venv/lib/python3.13/site-packages/starlette/formparsers.py:8
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/formpars
ers.py:8: PendingDeprecationWarning: Please use `import python_multipart` instead.
    import multipart

app/tests/test_rooms.py::test_create_room
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/testclie
nt.py:234: DeprecationWarning: There is no current event loop
    loop = asyncio.get_event_loop()

app/tests/test_rooms.py: 26 warnings
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sqlmodel/_compat.p
y:556: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal i
n a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime
.now(datetime.UTC).
    values, fields_set, validation_error = validate_model(self.__class__, data)

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plu
gin.py:769: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been rede
fined in
  /home/db/code/shared_whiteboard_backend/app/tests/conftest.py:91
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.
  
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=================================== short test summary info ===================================
FAILED app/tests/test_rooms.py::test_room_cleanup - sqlalchemy.exc.OperationalError: (sqlite3.O
perationalError) no such table: room
========================== 1 failed, 4 passed, 29 warnings in 0.30s ===========================

```

---

I see the issue now. The test is failing because the `room` table doesn't exist in the test database. This is happening because we need to ensure the database tables are properly created before running the tests. Let's check the models file to see how the Room model is defined:




---

Read file: app/models/models.py

---

I see the issue. We need to update the models to use the correct datetime import and UTC timezone, and we need to ensure the database tables are properly created in the test environment. Let's make these changes:

1. First, let's update the models.py file:




---

Cancelled

---

_**User**_

ah sorry. in the test fixture. do we import the models before we yield the in memory db? make sure this is done

---

_**Assistant**_

Ah yes, that's a good point! We need to ensure the models are imported before creating the database tables in the test fixture. Let's check and modify the conftest.py file:



---

Read file: app/tests/conftest.py

---

I see the issue. We need to import the models before creating the database tables. Let's modify the conftest.py file:




---

```diff
  from app.services.redis_service import redis_service, RedisService
  from app.core.config import settings
+ from app.models.models import Room, DrawingData, UserSession  # Import all models
  
  # Create in-memory SQLite database for testing
  @pytest.fixture(name="engine")
  def engine_fixture():
+     # Import models to ensure they are registered with SQLModel
+     from app.models import models
+     
      engine = create_engine(
          "sqlite://",
```

---

Now let's run the tests again to see if this fixes the issue:




---

```bash
source .venv/bin/activate && pytest app/tests/test_rooms.py -v
```

```
===================================== test session starts =====================================
platform linux -- Python 3.13.2, pytest-8.0.2, pluggy-1.5.0 -- /home/db/code/shared_whiteboard_
backend/.venv/bin/python3
cachedir: .pytest_cache
rootdir: /home/db/code/shared_whiteboard_backend
configfile: pyproject.toml
plugins: anyio-4.9.0, cov-4.1.0, asyncio-0.23.5
asyncio: mode=Mode.STRICT
collected 5 items                                                                             

app/tests/test_rooms.py::test_create_room PASSED                                        [ 20%]
app/tests/test_rooms.py::test_get_room PASSED                                           [ 40%]
app/tests/test_rooms.py::test_get_nonexistent_room PASSED                               [ 60%]
app/tests/test_rooms.py::test_room_limit_per_ip PASSED                                  [ 80%]
app/tests/test_rooms.py::test_room_cleanup FAILED                                       [100%]

========================================== FAILURES ===========================================
______________________________________ test_room_cleanup ______________________________________

self = <sqlalchemy.engine.base.Connection object at 0x7357dd1d4a10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7357de0592b0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7357dd1cbe70>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7357dd2d7950>
parameters = [('2025-04-23 05:35:44.678505', 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7357de0592b0>
cursor = <sqlite3.Cursor object at 0x7357dd1e8ac0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count = ?'
parameters = ('2025-04-23 05:35:44.678505', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7357dd1cbe70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: room

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: OperationalError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x7357dd2d7230>
session = <sqlmodel.orm.session.Session object at 0x7357dd2d7490>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7357dd145fc0>

    @pytest.mark.asyncio
    async def test_room_cleanup(client: TestClient, session, mock_redis_service):
        """Test room cleanup for inactive rooms"""
        # Create a room
        response = client.post("/api/v1/rooms")
        room_id = response.json()["id"]
    
        # Get the room and modify its last_activity to be old
        room = session.get(Room, room_id)
        room.last_activity = datetime.utcnow() - timedelta(minutes=10)
        session.add(room)
        session.commit()
    
        # Import and run cleanup
        from app.core.tasks import cleanup_inactive_rooms
>       await cleanup_inactive_rooms()

app/tests/test_rooms.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
app/core/tasks.py:19: in cleanup_inactive_rooms
    inactive_rooms = session.exec(
.venv/lib/python3.13/site-packages/sqlmodel/orm/session.py:66: in exec
    results = super().execute(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7357de0592b0>
cursor = <sqlite3.Cursor object at 0x7357dd1e8ac0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count = ?'
parameters = ('2025-04-23 05:35:44.678505', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7357dd1cbe70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: room
E       [SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active
_user_count
E       FROM room 
E       WHERE room.last_activity < ? AND room.active_user_count = ?]
E       [parameters: ('2025-04-23 05:35:44.678505', 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: OperationalError
------------------------------------ Captured stderr call -------------------------------------
2025-04-22 22:40:44,679 - app.core.tasks - ERROR - Error in cleanup_inactive_rooms: (sqlite3.Op
erationalError) no such table: room
[SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_user_co
unt
FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:35:44.678505', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
-------------------------------------- Captured log call --------------------------------------
ERROR    app.core.tasks:tasks.py:37 Error in cleanup_inactive_rooms: (sqlite3.OperationalError)
 no such table: room
[SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_ip, room.active_user_co
unt
FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:35:44.678505', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
====================================== warnings summary =======================================
.venv/lib/python3.13/site-packages/starlette/formparsers.py:8
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/formpars
ers.py:8: PendingDeprecationWarning: Please use `import python_multipart` instead.
    import multipart

app/tests/test_rooms.py::test_create_room
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/testclie
nt.py:234: DeprecationWarning: There is no current event loop
    loop = asyncio.get_event_loop()

app/tests/test_rooms.py: 26 warnings
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sqlmodel/_compat.p
y:556: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal i
n a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime
.now(datetime.UTC).
    values, fields_set, validation_error = validate_model(self.__class__, data)

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plu
gin.py:769: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been rede
fined in
  /home/db/code/shared_whiteboard_backend/app/tests/conftest.py:95
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.
  
    warnings.warn(

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/app/tests/test_rooms.py:62: DeprecationWarning: datet
ime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone
-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    room.last_activity = datetime.utcnow() - timedelta(minutes=10)

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/app/core/tasks.py:16: DeprecationWarning: datetime.da
tetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware
 objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    cutoff_time = datetime.utcnow() - timedelta(minutes=settings.ROOM_CLEANUP_MINUTES)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=================================== short test summary info ===================================
FAILED app/tests/test_rooms.py::test_room_cleanup - sqlalchemy.exc.OperationalError: (sqlite3.O
perationalError) no such table: room
========================== 1 failed, 4 passed, 31 warnings in 0.28s ===========================

```

---

I see the issue now. The problem is that the `cleanup_inactive_rooms` function in tasks.py is using a different database engine than the test database. We need to modify the tasks.py file to use the test database engine when running tests. Let's update the tasks.py file:





---

```diff
- from datetime import datetime, timedelta
+ from datetime import datetime, timedelta, UTC
  import asyncio
  import logging
  logger = logging.getLogger(__name__)
  
- async def cleanup_inactive_rooms():
+ async def cleanup_inactive_rooms(session: Session = None):
      """Clean up rooms that have been inactive for more than 5 minutes"""
      try:
-         with Session(engine) as session:
-             cutoff_time = datetime.utcnow() - timedelta(minutes=settings.ROOM_CLEANUP_MINUTES)
-             
-             # Find inactive rooms
-             inactive_rooms = session.exec(
-                 select(Room).where(
-                     (Room.last_activity < cutoff_time) & 
-                     (Room.active_user_count == 0)
-                 )
-             ).all()
-             
-             # Clean up each inactive room
-             for room in inactive_rooms:
-                 # Clean up Redis data
-                 await redis_service.delete_room_data(room.id)
-                 
-                 # Delete room from database
-                 session.delete(room)
-                 logger.info(f"Cleaned up inactive room: {room.id}")
-             
-             session.commit()
-     except Exception as e:
-         logger.error(f"Error in cleanup_inactive_rooms: {str(e)}")
-         # Re-raise the exception to ensure the test fails if cleanup fails
-         raise
+         # Use provided session or create a new one
+         if session is None:
+             with Session(engine) as session:
+                 await _cleanup_rooms(session)
+         else:
+             await _cleanup_rooms(session)
+     except Exception as e:
+         logger.error(f"Error in cleanup_inactive_rooms: {str(e)}")
+         # Re-raise the exception to ensure the test fails if cleanup fails
+         raise
+ 
+ async def _cleanup_rooms(session: Session):
+     """Internal function to perform the actual cleanup"""
+     cutoff_time = datetime.now(UTC) - timedelta(minutes=settings.ROOM_CLEANUP_MINUTES)
+     
+     # Find inactive rooms
+     inactive_rooms = session.exec(
+         select(Room).where(
+             (Room.last_activity < cutoff_time) & 
+             (Room.active_user_count == 0)
+         )
+     ).all()
+     
+     # Clean up each inactive room
+     for room in inactive_rooms:
+         # Clean up Redis data
+         await redis_service.delete_room_data(room.id)
+         
+         # Delete room from database
+         session.delete(room)
+         logger.info(f"Cleaned up inactive room: {room.id}")
+     
+     session.commit()
  
  async def periodic_cleanup():
```

---

Now let's update the test to use the session from the fixture:




---

```diff
  from fastapi.testclient import TestClient
  from app.models.models import Room
- from datetime import datetime, timedelta
+ from datetime import datetime, timedelta, UTC
  
  def test_create_room(client: TestClient, session):
      # Get the room and modify its last_activity to be old
      room = session.get(Room, room_id)
-     room.last_activity = datetime.utcnow() - timedelta(minutes=10)
+     room.last_activity = datetime.now(UTC) - timedelta(minutes=10)
      session.add(room)
      session.commit()
      
      # Import and run cleanup
      from app.core.tasks import cleanup_inactive_rooms
-     await cleanup_inactive_rooms()
+     await cleanup_inactive_rooms(session=session)
      
      # Verify room was deleted
```

---

Now let's run the tests again to see if this fixes the issue:





---

```bash
source .venv/bin/activate && pytest app/tests/test_rooms.py -v
```

```
(.venv) .venvshared_whiteboard_backend [main●●] % source .venv/bin/activate && pytest app/tests
/test_rooms.py -v                                 source .venv/bin/activate && pytest app/tests
/test_rooms.py -v
===================================== test session starts =====================================
platform linux -- Python 3.13.2, pytest-8.0.2, pluggy-1.5.0 -- /home/db/code/shared_whiteboard_
backend/.venv/bin/python3
cachedir: .pytest_cache
rootdir: /home/db/code/shared_whiteboard_backend
configfile: pyproject.toml
plugins: anyio-4.9.0, cov-4.1.0, asyncio-0.23.5
asyncio: mode=Mode.STRICT
collected 5 items                                                                             

app/tests/test_rooms.py::test_create_room PASSED                                        [ 20%]
app/tests/test_rooms.py::test_get_room PASSED                                           [ 40%]
app/tests/test_rooms.py::test_get_nonexistent_room PASSED                               [ 60%]
app/tests/test_rooms.py::test_room_limit_per_ip PASSED                                  [ 80%]
app/tests/test_rooms.py::test_room_cleanup FAILED                                       [100%]

========================================== FAILURES ===========================================
______________________________________ test_room_cleanup ______________________________________

client = <starlette.testclient.TestClient object at 0x78d0655db360>
session = <sqlmodel.orm.session.Session object at 0x78d0655db5c0>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x78d0654526c0>

    @pytest.mark.asyncio
    async def test_room_cleanup(client: TestClient, session, mock_redis_service):
        """Test room cleanup for inactive rooms"""
        # Create a room
        response = client.post("/api/v1/rooms")
        room_id = response.json()["id"]
    
        # Get the room and modify its last_activity to be old
        room = session.get(Room, room_id)
        room.last_activity = datetime.now(UTC) - timedelta(minutes=10)
        session.add(room)
        session.commit()
    
        # Import and run cleanup
        from app.core.tasks import cleanup_inactive_rooms
>       await cleanup_inactive_rooms(session=session)

app/tests/test_rooms.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
app/core/tasks.py:20: in cleanup_inactive_rooms
    await _cleanup_rooms(session)
app/core/tasks.py:41: in _cleanup_rooms
    await redis_service.delete_room_data(room.id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.redis_service.RedisService object at 0x78d06635e510>
room_id = '20f9dd74-e81c-4450-a384-2126ea72e3c1'

    async def delete_room_data(self, room_id: str):
>       keys = await self.redis.keys(f"room:{room_id}:*")
E       AttributeError: 'NoneType' object has no attribute 'keys'

app/services/redis_service.py:66: AttributeError
------------------------------------ Captured stderr call -------------------------------------
2025-04-22 22:41:01,469 - app.core.tasks - ERROR - Error in cleanup_inactive_rooms: 'NoneType' 
object has no attribute 'keys'
-------------------------------------- Captured log call --------------------------------------
ERROR    app.core.tasks:tasks.py:22 Error in cleanup_inactive_rooms: 'NoneType' object has no a
ttribute 'keys'
====================================== warnings summary =======================================
.venv/lib/python3.13/site-packages/starlette/formparsers.py:8
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/formpars
ers.py:8: PendingDeprecationWarning: Please use `import python_multipart` instead.
    import multipart

app/tests/test_rooms.py::test_create_room
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/starlette/testclie
nt.py:234: DeprecationWarning: There is no current event loop
    loop = asyncio.get_event_loop()

app/tests/test_rooms.py: 26 warnings
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sqlmodel/_compat.p
y:556: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal i
n a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime
.now(datetime.UTC).
    values, fields_set, validation_error = validate_model(self.__class__, data)

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plu
gin.py:769: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been rede
fined in
  /home/db/code/shared_whiteboard_backend/app/tests/conftest.py:95
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.
  
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=================================== short test summary info ===================================
FAILED app/tests/test_rooms.py::test_room_cleanup - AttributeError: 'NoneType' object has no at
tribute 'keys'
========================== 1 failed, 4 passed, 29 warnings in 0.10s ===========================
(.venv) .venvshared_whiteboard_backend [main●●] %
```

---


Now we have a different error - the Redis service mock is not properly set up. Let's check the Redis service implementation and update our mock accordingly:



---

Read file: app/services/redis_service.py

---

Let's update the mock Redis service in conftest.py to properly mock the Redis instance:




---



---



---



---

