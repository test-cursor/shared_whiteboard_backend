<!-- Generated by SpecStory -->

# Running Pytest and Analyzing Failures (2025-04-22 22:16:13)

_**User**_

@Web @tests 

i want u to run all the tests via pytest. remember to source the .venv first.

afterwards, i want u to analyze each failing test. understand the purpose of the test. the reason its failing, and brainstorm some solutions. dump ur understanding into FAILING_TESTS.md

---

_**Assistant**_

I'll help you run the tests and analyze any failures. Let's do this step by step.

First, I'll source the virtual environment and run pytest:


---

```bash
source .venv/bin/activate && pytest -v
```

```
(.venv) .venvshared_whiteboard_backend [main‚óè] % 
    self._flush(objects)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4488: in _flush
    with util.safe_reraise():
.venv/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit
__
    raise exc_value.with_traceback(exc_tb)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4449: in _flush
    flush_context.execute()
.venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_
insert_statemen
ts
                   result = connection.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_o
n_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_c
lauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_c
ontext
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_sing
le_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_db
api_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_sing
le_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7
b6f33d425d0>
cursor = <sqlite3.Cursor object at 0x7b6f33dd4940>
statement = 'INSERT INTO usersession (token, username, room_id, last_active) VAL
UES (?, ?, ?, ?
)'
               parameters = ('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0Z
XN0dXNlciIsImV4cCI6MTc0NTk5MDY
4NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw', 'testuser', None, '2025-04-23
 05:24:45.070190')
                              context = <sqlalchemy.dialects.sqlite.base.SQLiteE
xecutionContext object at 0x7b6f33dd03d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constrain
t failed: users
ession.token
               E       [SQL: INSERT INTO usersession (token, username, room_id,
last_active) VALUES (?, ?, ?, 
?)]
               E       [parameters: ('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzd
WIiOiJ0ZXN0dXNlciIsImV4cCI6MTc
0NTk5MDY4NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw', 'testuser', None, '20
25-04-23 05:24:45.070190')]
                              E       (Background on this error at: https://sqla
lche.me/e/20/gkpj)

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: IntegrityEr
ror
______________________________________ test_room_cleanup _______________________
_______________

self = <sqlalchemy.engine.base.Connection object at 0x7b6f33db9c10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at
0x7b6f34c452b0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7b
6f33d3b5b0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x7b6f33dc
2780>
parameters = [('2025-04-23 05:19:45.493500', 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7
b6f34c452b0>
cursor = <sqlite3.Cursor object at 0x7b6f31e53ec0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_i
p, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count
 = ?'          parameters = ('2025-04-23 05:19:45.493500', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7b
6f33d3b5b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: room

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: Operational
Error

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x7b6f33dd9550>
session = <sqlmodel.orm.session.Session object at 0x7b6f33dd8950>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f33dd1e00>

    @pytest.mark.asyncio
    async def test_room_cleanup(client: TestClient, session, mock_redis_service)
:
        """Test room cleanup for inactive rooms"""
        # Create a room
        response = client.post("/api/v1/rooms")
        room_id = response.json()["id"]
    
        # Get the room and modify its last_activity to be old
        room = session.get(Room, room_id)
        room.last_activity = datetime.utcnow() - timedelta(minutes=10)
        session.add(room)
        session.commit()
    
        # Import and run cleanup
        from app.core.tasks import cleanup_inactive_rooms
>       await cleanup_inactive_rooms()

app/tests/test_rooms.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
app/core/tasks.py:19: in cleanup_inactive_rooms
    inactive_rooms = session.exec(
.venv/lib/python3.13/site-packages/sqlmodel/orm/session.py:66: in exec
    results = super().execute(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2251: in _execute_i
nternal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:306: in orm_execute
_statement
    result = conn.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:523: in _execute_o
n_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1638: in _execute_c
lauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1843: in _execute_c
ontext
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1983: in _exec_sing
le_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2352: in _handle_db
api_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1964: in _exec_sing
le_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x7
b6f34c452b0>
cursor = <sqlite3.Cursor object at 0x7b6f31e53ec0>
statement = 'SELECT room.id, room.created_at, room.last_activity, room.creator_i
p, room.active_
user_count \nFROM room \nWHERE room.last_activity < ? AND room.active_user_count
 = ?'          parameters = ('2025-04-23 05:19:45.493500', 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x7b
6f33d3b5b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such tabl
e: room
E       [SQL: SELECT room.id, room.created_at, room.last_activity, room.creator_
ip, room.active
_user_count
               E       FROM room 
E       WHERE room.last_activity < ? AND room.active_user_count = ?]
E       [parameters: ('2025-04-23 05:19:45.493500', 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:945: Operational
Error
------------------------------------ Captured stderr call ----------------------
---------------
2025-04-22 22:24:45,494 - app.core.tasks - ERROR - Error in cleanup_inactive_roo
ms: (sqlite3.Op
erationalError) no such table: room
               [SQL: SELECT room.id, room.created_at, room.last_activity, room.c
reator_ip, room.active_user_co
unt
               FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:19:45.493500', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
-------------------------------------- Captured log call -----------------------
---------------
ERROR    app.core.tasks:tasks.py:37 Error in cleanup_inactive_rooms: (sqlite3.Op
erationalError)
 no such table: room
               [SQL: SELECT room.id, room.created_at, room.last_activity, room.c
reator_ip, room.active_user_co
unt
               FROM room 
WHERE room.last_activity < ? AND room.active_user_count = ?]
[parameters: ('2025-04-23 05:19:45.493500', 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
______________________________ test_websocket_connection_success _______________
_______________

client = <starlette.testclient.TestClient object at 0x7b6f33dd9d50>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f33dd9d50>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = 'bcfeaf33-0f76-4903-a6c4-2547f0783ddb'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f33d3ab20>

    def test_websocket_connection_success(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test successful WebSocket connection"""
        with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:
            # Verify connection is established
>           data = websocket.receive_json()

app/tests/test_websocket.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:357: in receive_json
    self._raise_on_close(message)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <starlette.testclient.WebSocketTestSession object at 0x7b6f33efdbe0>
message = {'code': 1011, 'type': 'websocket.close'}

    def _raise_on_close(self, message: Message) -> None:
        if message["type"] == "websocket.close":
>           raise WebSocketDisconnect(message.get("code", 1000))
E           starlette.websockets.WebSocketDisconnect: 1011

.venv/lib/python3.13/site-packages/starlette/testclient.py:316: WebSocketDisconn
ect

During handling of the above exception, another exception occurred:

client = <starlette.testclient.TestClient object at 0x7b6f33dd9d50>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f33dd9d50>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = 'bcfeaf33-0f76-4903-a6c4-2547f0783ddb'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f33d3ab20>

    def test_websocket_connection_success(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test successful WebSocket connection"""
>       with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:

app/tests/test_websocket.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:289: in __exit__
    raise message
.venv/lib/python3.13/site-packages/starlette/testclient.py:300: in _run
    loop.run_until_complete(self.app(scope, receive, send))
.venv/lib/python3.13/site-packages/nest_asyncio.py:98: in run_until_complete
    return f.result()
/usr/lib/python3.13/asyncio/futures.py:199: in result
    raise self._exception.with_traceback(self._exception_tb)
/usr/lib/python3.13/asyncio/tasks.py:306: in __step_run_and_handle_result
    result = coro.throw(exc)
.venv/lib/python3.13/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:146: in __call
__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:70: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/exceptions.py:58: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:297: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:68: in app
    await func(session)
.venv/lib/python3.13/site-packages/fastapi/routing.py:273: in app
    await dependant.call(**values)
app/api/routes/room.py:121: in websocket_endpoint
    raise e
app/api/routes/room.py:75: in websocket_endpoint
    await redis_service.add_user_to_room(room_id, token, username)
app/services/redis_service.py:33: in add_user_to_room
    await self.redis.hset(f"room:{room_id}:users", user_id, username)
.venv/lib/python3.13/site-packages/redis/asyncio/client.py:611: in execute_comma
nd
    conn = self.connection or await pool.get_connection(command_name, **options)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1064: in get_conn
ection
    await self.ensure_connection(connection)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1097: in ensure_c
onnection
    await connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <redis.asyncio.connection.Connection(host=localhost,port=6379,db=0)>

    async def connect(self):
        """Connects to the Redis server if not already connected"""
        if self.is_connected:
            return
        try:
            await self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect()
            )
        except asyncio.CancelledError:
            raise  # in 3.7 and earlier, this is an Exception, not BaseException
        except (socket.timeout, asyncio.TimeoutError):
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno
111] Connect ca
ll failed ('::1', 6379, 0, 0), [Errno 111] Connect call failed ('127.0.0.1', 637
9) connecting to localhost:6379.
                              
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:289: ConnectionEr
ror
_______________________________ test_websocket_cursor_position _________________
_______________

client = <starlette.testclient.TestClient object at 0x7b6f32b046e0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32b046e0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = 'a19bc48f-5664-4b4f-877d-f7f5f68f120d'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f32b26880>

    def test_websocket_cursor_position(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test sending and receiving cursor position updates"""
        with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:
            # Wait for connection message
>           websocket.receive_json()

app/tests/test_websocket.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:357: in receive_json
    self._raise_on_close(message)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <starlette.testclient.WebSocketTestSession object at 0x7b6f33d434d0>
message = {'code': 1011, 'type': 'websocket.close'}

    def _raise_on_close(self, message: Message) -> None:
        if message["type"] == "websocket.close":
>           raise WebSocketDisconnect(message.get("code", 1000))
E           starlette.websockets.WebSocketDisconnect: 1011

.venv/lib/python3.13/site-packages/starlette/testclient.py:316: WebSocketDisconn
ect

During handling of the above exception, another exception occurred:

client = <starlette.testclient.TestClient object at 0x7b6f32b046e0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32b046e0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = 'a19bc48f-5664-4b4f-877d-f7f5f68f120d'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f32b26880>

    def test_websocket_cursor_position(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test sending and receiving cursor position updates"""
>       with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:

app/tests/test_websocket.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:289: in __exit__
    raise message
.venv/lib/python3.13/site-packages/starlette/testclient.py:300: in _run
    loop.run_until_complete(self.app(scope, receive, send))
.venv/lib/python3.13/site-packages/nest_asyncio.py:98: in run_until_complete
    return f.result()
/usr/lib/python3.13/asyncio/futures.py:199: in result
    raise self._exception.with_traceback(self._exception_tb)
/usr/lib/python3.13/asyncio/tasks.py:306: in __step_run_and_handle_result
    result = coro.throw(exc)
.venv/lib/python3.13/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:146: in __call
__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:70: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/exceptions.py:58: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:297: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:68: in app
    await func(session)
.venv/lib/python3.13/site-packages/fastapi/routing.py:273: in app
    await dependant.call(**values)
app/api/routes/room.py:121: in websocket_endpoint
    raise e
app/api/routes/room.py:75: in websocket_endpoint
    await redis_service.add_user_to_room(room_id, token, username)
app/services/redis_service.py:33: in add_user_to_room
    await self.redis.hset(f"room:{room_id}:users", user_id, username)
.venv/lib/python3.13/site-packages/redis/asyncio/client.py:611: in execute_comma
nd
    conn = self.connection or await pool.get_connection(command_name, **options)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1064: in get_conn
ection
    await self.ensure_connection(connection)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1097: in ensure_c
onnection
    await connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <redis.asyncio.connection.Connection(host=localhost,port=6379,db=0)>

    async def connect(self):
        """Connects to the Redis server if not already connected"""
        if self.is_connected:
            return
        try:
            await self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect()
            )
        except asyncio.CancelledError:
            raise  # in 3.7 and earlier, this is an Exception, not BaseException
        except (socket.timeout, asyncio.TimeoutError):
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno
111] Connect ca
ll failed ('::1', 6379, 0, 0), [Errno 111] Connect call failed ('127.0.0.1', 637
9) connecting to localhost:6379.
                              
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:289: ConnectionEr
ror
________________________________ test_websocket_drawing_action _________________
_______________

client = <starlette.testclient.TestClient object at 0x7b6f32be9a90>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32be9a90>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = '81ef435b-fffc-4ada-8e6f-ab78ebfa5e5e'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f33d55540>

    def test_websocket_drawing_action(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test sending and receiving drawing actions"""
        with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:
            # Wait for connection message
>           websocket.receive_json()

app/tests/test_websocket.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:357: in receive_json
    self._raise_on_close(message)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <starlette.testclient.WebSocketTestSession object at 0x7b6f33ebf5c0>
message = {'code': 1011, 'type': 'websocket.close'}

    def _raise_on_close(self, message: Message) -> None:
        if message["type"] == "websocket.close":
>           raise WebSocketDisconnect(message.get("code", 1000))
E           starlette.websockets.WebSocketDisconnect: 1011

.venv/lib/python3.13/site-packages/starlette/testclient.py:316: WebSocketDisconn
ect

During handling of the above exception, another exception occurred:

client = <starlette.testclient.TestClient object at 0x7b6f32be9a90>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32be9a90>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
NX0.j5Pp7zL_C2IVnX4EM3FrVGy-gkHeLX69erYuOpcBtFw'
               test_room = '81ef435b-fffc-4ada-8e6f-ab78ebfa5e5e'
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f33d55540>

    def test_websocket_drawing_action(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        mock_redis_service
    ):
        """Test sending and receiving drawing actions"""
>       with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:

app/tests/test_websocket.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:289: in __exit__
    raise message
.venv/lib/python3.13/site-packages/starlette/testclient.py:300: in _run
    loop.run_until_complete(self.app(scope, receive, send))
.venv/lib/python3.13/site-packages/nest_asyncio.py:98: in run_until_complete
    return f.result()
/usr/lib/python3.13/asyncio/futures.py:199: in result
    raise self._exception.with_traceback(self._exception_tb)
/usr/lib/python3.13/asyncio/tasks.py:306: in __step_run_and_handle_result
    result = coro.throw(exc)
.venv/lib/python3.13/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:146: in __call
__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:70: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/exceptions.py:58: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:297: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:68: in app
    await func(session)
.venv/lib/python3.13/site-packages/fastapi/routing.py:273: in app
    await dependant.call(**values)
app/api/routes/room.py:121: in websocket_endpoint
    raise e
app/api/routes/room.py:75: in websocket_endpoint
    await redis_service.add_user_to_room(room_id, token, username)
app/services/redis_service.py:33: in add_user_to_room
    await self.redis.hset(f"room:{room_id}:users", user_id, username)
.venv/lib/python3.13/site-packages/redis/asyncio/client.py:611: in execute_comma
nd
    conn = self.connection or await pool.get_connection(command_name, **options)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1064: in get_conn
ection
    await self.ensure_connection(connection)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1097: in ensure_c
onnection
    await connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <redis.asyncio.connection.Connection(host=localhost,port=6379,db=0)>

    async def connect(self):
        """Connects to the Redis server if not already connected"""
        if self.is_connected:
            return
        try:
            await self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect()
            )
        except asyncio.CancelledError:
            raise  # in 3.7 and earlier, this is an Exception, not BaseException
        except (socket.timeout, asyncio.TimeoutError):
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno
111] Connect ca
ll failed ('::1', 6379, 0, 0), [Errno 111] Connect call failed ('127.0.0.1', 637
9) connecting to localhost:6379.
                              
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:289: ConnectionEr
ror
______________________________ test_websocket_disconnect_cleanup _______________
_______________

client = <starlette.testclient.TestClient object at 0x7b6f32b0a7b0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32b0a7b0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
Nn0.oT-I4Ht6hEDdb8pxzExA7b5ENasIl_ZFzMnl0DTr3cg'
               test_room = 'f283e7d1-981b-4a23-8592-20c4d5f862a4'
session = <sqlmodel.orm.session.Session object at 0x7b6f33dc97c0>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f32b08d60>

    def test_websocket_disconnect_cleanup(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        session,
        mock_redis_service
    ):
        """Test cleanup after WebSocket disconnection"""
        with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:
            # Wait for connection message
>           websocket.receive_json()

app/tests/test_websocket.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:357: in receive_json
    self._raise_on_close(message)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <starlette.testclient.WebSocketTestSession object at 0x7b6f33ebf100>
message = {'code': 1011, 'type': 'websocket.close'}

    def _raise_on_close(self, message: Message) -> None:
        if message["type"] == "websocket.close":
>           raise WebSocketDisconnect(message.get("code", 1000))
E           starlette.websockets.WebSocketDisconnect: 1011

.venv/lib/python3.13/site-packages/starlette/testclient.py:316: WebSocketDisconn
ect

During handling of the above exception, another exception occurred:

client = <starlette.testclient.TestClient object at 0x7b6f32b0a7b0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32b0a7b0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
Nn0.oT-I4Ht6hEDdb8pxzExA7b5ENasIl_ZFzMnl0DTr3cg'
               test_room = 'f283e7d1-981b-4a23-8592-20c4d5f862a4'
session = <sqlmodel.orm.session.Session object at 0x7b6f33dc97c0>
mock_redis_service = <async_generator object mock_redis_service_fixture at 0x7b6
f32b08d60>

    def test_websocket_disconnect_cleanup(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room,
        session,
        mock_redis_service
    ):
        """Test cleanup after WebSocket disconnection"""
>       with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:

app/tests/test_websocket.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:289: in __exit__
    raise message
.venv/lib/python3.13/site-packages/starlette/testclient.py:300: in _run
    loop.run_until_complete(self.app(scope, receive, send))
.venv/lib/python3.13/site-packages/nest_asyncio.py:98: in run_until_complete
    return f.result()
/usr/lib/python3.13/asyncio/futures.py:199: in result
    raise self._exception.with_traceback(self._exception_tb)
/usr/lib/python3.13/asyncio/tasks.py:306: in __step_run_and_handle_result
    result = coro.throw(exc)
.venv/lib/python3.13/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:146: in __call
__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:70: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/exceptions.py:58: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:297: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:68: in app
    await func(session)
.venv/lib/python3.13/site-packages/fastapi/routing.py:273: in app
    await dependant.call(**values)
app/api/routes/room.py:121: in websocket_endpoint
    raise e
app/api/routes/room.py:75: in websocket_endpoint
    await redis_service.add_user_to_room(room_id, token, username)
app/services/redis_service.py:33: in add_user_to_room
    await self.redis.hset(f"room:{room_id}:users", user_id, username)
.venv/lib/python3.13/site-packages/redis/asyncio/client.py:611: in execute_comma
nd
    conn = self.connection or await pool.get_connection(command_name, **options)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1064: in get_conn
ection
    await self.ensure_connection(connection)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1097: in ensure_c
onnection
    await connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <redis.asyncio.connection.Connection(host=localhost,port=6379,db=0)>

    async def connect(self):
        """Connects to the Redis server if not already connected"""
        if self.is_connected:
            return
        try:
            await self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect()
            )
        except asyncio.CancelledError:
            raise  # in 3.7 and earlier, this is an Exception, not BaseException
        except (socket.timeout, asyncio.TimeoutError):
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno
111] Connect ca
ll failed ('::1', 6379, 0, 0), [Errno 111] Connect call failed ('127.0.0.1', 637
9) connecting to localhost:6379.
                              
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:289: ConnectionEr
ror
____________________________ test_websocket_invalid_message_format _____________
_______________

client = <starlette.testclient.TestClient object at 0x7b6f32e535f0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32e535f0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
Nn0.oT-I4Ht6hEDdb8pxzExA7b5ENasIl_ZFzMnl0DTr3cg'
               test_room = 'f65b7888-b2b3-4cb5-a431-7ef2fe2deb0d'

    def test_websocket_invalid_message_format(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room
    ):
        """Test sending invalid message format"""
        with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:
            # Wait for connection message
>           websocket.receive_json()

app/tests/test_websocket.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:357: in receive_json
    self._raise_on_close(message)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <starlette.testclient.WebSocketTestSession object at 0x7b6f33d6b770>
message = {'code': 1011, 'type': 'websocket.close'}

    def _raise_on_close(self, message: Message) -> None:
        if message["type"] == "websocket.close":
>           raise WebSocketDisconnect(message.get("code", 1000))
E           starlette.websockets.WebSocketDisconnect: 1011

.venv/lib/python3.13/site-packages/starlette/testclient.py:316: WebSocketDisconn
ect

During handling of the above exception, another exception occurred:

client = <starlette.testclient.TestClient object at 0x7b6f32e535f0>
websocket_client = <bound method TestClient.websocket_connect of <starlette.test
client.TestClie
nt object at 0x7b6f32e535f0>>
               auth_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZX
N0dXNlciIsImV4cCI6MTc0NTk5MDY4
Nn0.oT-I4Ht6hEDdb8pxzExA7b5ENasIl_ZFzMnl0DTr3cg'
               test_room = 'f65b7888-b2b3-4cb5-a431-7ef2fe2deb0d'

    def test_websocket_invalid_message_format(
        client: TestClient,
        websocket_client,
        auth_token,
        test_room
    ):
        """Test sending invalid message format"""
>       with websocket_client(
            f"/api/v1/ws/{test_room}?token={auth_token}"
        ) as websocket:

app/tests/test_websocket.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/starlette/testclient.py:289: in __exit__
    raise message
.venv/lib/python3.13/site-packages/starlette/testclient.py:300: in _run
    loop.run_until_complete(self.app(scope, receive, send))
.venv/lib/python3.13/site-packages/nest_asyncio.py:98: in run_until_complete
    return f.result()
/usr/lib/python3.13/asyncio/futures.py:199: in result
    raise self._exception.with_traceback(self._exception_tb)
/usr/lib/python3.13/asyncio/tasks.py:306: in __step_run_and_handle_result
    result = coro.throw(exc)
.venv/lib/python3.13/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:146: in __call
__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:70: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/exceptions.py:58: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:297: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:68: in app
    await func(session)
.venv/lib/python3.13/site-packages/fastapi/routing.py:273: in app
    await dependant.call(**values)
app/api/routes/room.py:121: in websocket_endpoint
    raise e
app/api/routes/room.py:75: in websocket_endpoint
    await redis_service.add_user_to_room(room_id, token, username)
app/services/redis_service.py:33: in add_user_to_room
    await self.redis.hset(f"room:{room_id}:users", user_id, username)
.venv/lib/python3.13/site-packages/redis/asyncio/client.py:611: in execute_comma
nd
    conn = self.connection or await pool.get_connection(command_name, **options)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1064: in get_conn
ection
    await self.ensure_connection(connection)
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:1097: in ensure_c
onnection
    await connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
_ _ _ _ _ _ _ _

self = <redis.asyncio.connection.Connection(host=localhost,port=6379,db=0)>

    async def connect(self):
        """Connects to the Redis server if not already connected"""
        if self.is_connected:
            return
        try:
            await self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect()
            )
        except asyncio.CancelledError:
            raise  # in 3.7 and earlier, this is an Exception, not BaseException
        except (socket.timeout, asyncio.TimeoutError):
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno
111] Connect ca
ll failed ('::1', 6379, 0, 0), [Errno 111] Connect call failed ('127.0.0.1', 637
9) connecting to localhost:6379.
                              
.venv/lib/python3.13/site-packages/redis/asyncio/connection.py:289: ConnectionEr
ror
====================================== warnings summary ========================
===============
.venv/lib/python3.13/site-packages/starlette/formparsers.py:8
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sta
rlette/formpars
ers.py:8: PendingDeprecationWarning: Please use `import python_multipart` instea
d.                 import multipart

app/tests/test_auth.py::test_login_success
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sta
rlette/testclie
nt.py:234: DeprecationWarning: There is no current event loop
                   loop = asyncio.get_event_loop()

app/tests/test_auth.py::test_login_success
app/tests/test_auth.py::test_multiple_logins_same_user
app/tests/test_auth.py::test_multiple_logins_same_user
app/tests/test_websocket.py::test_websocket_connection_success
app/tests/test_websocket.py::test_websocket_cursor_position
app/tests/test_websocket.py::test_websocket_drawing_action
app/tests/test_websocket.py::test_websocket_disconnect_cleanup
app/tests/test_websocket.py::test_websocket_invalid_message_format
  /home/db/code/shared_whiteboard_backend/app/core/security.py:13: DeprecationWa
rning: datetime
.datetime.utcnow() is deprecated and scheduled for removal in a future version.
Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(
datetime.UTC).                    expire = datetime.utcnow() + timedelta(minutes
=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

app/tests/test_auth.py: 3 warnings
app/tests/test_rooms.py: 26 warnings
app/tests/test_websocket.py: 17 warnings
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/sql
model/_compat.p
y:556: DeprecationWarning: datetime.datetime.utcnow() is deprecated and schedule
d for removal in a future version. Use timezone-aware objects to represent datet
imes in UTC: datetime.datetime.now(datetime.UTC).
                                                 values, fields_set, validation_
error = validate_model(self.__class__, data)

app/tests/test_auth.py::test_login_success
  /home/db/code/shared_whiteboard_backend/app/tests/test_auth.py:27: Deprecation
Warning: 
          üö® You probably want to use `session.exec()` instead of `session.query
()`.
  
          `session.exec()` is SQLModel's own short version with increased type
          annotations.
  
          Or otherwise you might want to use `session.execute()` instead of
          `session.query()`.
          
    user_session = session.query(UserSession).filter(UserSession.token == token)
.first()

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/.venv/lib/python3.13/site-packages/pyt
est_asyncio/plu
gin.py:769: DeprecationWarning: The event_loop fixture provided by pytest-asynci
o has been redefined in
                                /home/db/code/shared_whiteboard_backend/app/test
s/conftest.py:91
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_polic
y
  fixture.
  
    warnings.warn(

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/app/tests/test_rooms.py:62: Deprecatio
nWarning: datet
ime.datetime.utcnow() is deprecated and scheduled for removal in a future versio
n. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.n
ow(datetime.UTC).                 room.last_activity = datetime.utcnow() - timed
elta(minutes=10)

app/tests/test_rooms.py::test_room_cleanup
  /home/db/code/shared_whiteboard_backend/app/core/tasks.py:16: DeprecationWarni
ng: datetime.da
tetime.utcnow() is deprecated and scheduled for removal in a future version. Use
 timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(dat
etime.UTC).                       cutoff_time = datetime.utcnow() - timedelta(mi
nutes=settings.ROOM_CLEANUP_MINUTES)

app/tests/test_websocket.py::test_websocket_connection_success
app/tests/test_websocket.py::test_websocket_cursor_position
app/tests/test_websocket.py::test_websocket_drawing_action
app/tests/test_websocket.py::test_websocket_disconnect_cleanup
app/tests/test_websocket.py::test_websocket_invalid_message_format
  /home/db/code/shared_whiteboard_backend/app/api/routes/room.py:70: Deprecation
Warning: dateti
me.datetime.utcnow() is deprecated and scheduled for removal in a future version
. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.no
w(datetime.UTC).                  user_session.last_active = datetime.utcnow()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=================================== short test summary info ====================
===============
FAILED app/tests/test_auth.py::test_multiple_logins_same_user - sqlalchemy.exc.I
ntegrityError: 
(sqlite3.IntegrityError) UNIQUE constraint failed: usersess...
               FAILED app/tests/test_rooms.py::test_room_cleanup - sqlalchemy.ex
c.OperationalError: (sqlite3.O
perationalError) no such table: room
               FAILED app/tests/test_websocket.py::test_websocket_connection_suc
cess - redis.exceptions.Connec
tionError: Error Multiple exceptions: [Errno 111] Connect call fail...
               FAILED app/tests/test_websocket.py::test_websocket_cursor_positio
n - redis.exceptions.Connectio
nError: Error Multiple exceptions: [Errno 111] Connect call fail...
               FAILED app/tests/test_websocket.py::test_websocket_drawing_action
 - redis.exceptions.Connection
Error: Error Multiple exceptions: [Errno 111] Connect call fail...
               FAILED app/tests/test_websocket.py::test_websocket_disconnect_cle
anup - redis.exceptions.Connec
tionError: Error Multiple exceptions: [Errno 111] Connect call fail...
               FAILED app/tests/test_websocket.py::test_websocket_invalid_messag
e_format - redis.exceptions.Co
nnectionError: Error Multiple exceptions: [Errno 111] Connect call fail...
               ========================== 7 failed, 8 passed, 65 warnings in 1.3
0s ===========================

```

---

I see several failing tests. Let me analyze each one and create a FAILING_TESTS.md file to document the issues and potential solutions.



---

```diff
- # Failed Tests Report
- ## 3. WebSocket Tests
- The following WebSocket tests are all failing with the same error:
- - test_websocket_connection_success
- - test_websocket_cursor_position
- - test_websocket_drawing_action
- - test_websocket_disconnect_cleanup
- - test_websocket_invalid_message_format
- 
- **Error**: `redis.exceptions.ConnectionError: Error Multiple exceptions: [Errno 111] Connect call failed`
- **Cause**: The tests are unable to connect to Redis server at localhost:6379. This indicates that either:
- - Redis server is not running
- THIS IS BECAUSE I AM NOT RUNNING REDIS
- 
- **Fix Required**:
- Using a mock Redis service for tests instead of requiring a real Redis instance
- 
- ## Summary of Required Actions
- 1. Set up Redis for tests:
-    - implement proper mocking
   
```

---

I've created a comprehensive analysis of the failing tests in FAILING_TESTS.md. The main issues are:

1. A database constraint issue with multiple user sessions
2. Missing database table for rooms
3. Redis connection issues in WebSocket tests

Would you like me to help you address any of these specific issues? I can:

1. Help modify the database schema to handle multiple sessions
2. Set up proper database migrations for the room table
3. Fix the Redis mocking in the WebSocket tests

Which issue would you like to tackle first?

---

_**User**_

ok, i see that there is some failure in the understanding. i would like to point out some things to u, then u update the file

@auth.py 
the token data is the exact same per user. we can add a uuid to fix it

for test 2 @test_rooms.py , it seems like we do not make sure to pass in the correct instance. we are not passing in the in memory database.

for test 3
we are not properly mocking the database. we need to use dependency injection within @room.py , to ensure that we use the mocked version for the tests.

notice these lines for example

help me understand the issues completely. tell me now, all ur confusions and needed clarifications

---

_**Assistant**_

Thank you for the clarifications. Let me break down my understanding and ask for any remaining clarifications:

1. **Auth Token Issue**:
- I understand now that the token generation is deterministic based on username, so multiple logins for the same user generate identical tokens
- The solution would be to add a UUID to the token data to make it unique each time
- Question: Should we keep the username in the token data along with the UUID?

2. **Room Cleanup Test Issue**:
- The test is failing because we're not properly initializing the in-memory SQLite database for testing
- We need to ensure the test database is properly set up in conftest.py
- Question: Should we be using a fixture to create and initialize the test database before each test?

3. **WebSocket Tests Issue**:
- The main issue is that we're directly using `redis_service` in room.py instead of using dependency injection
- This makes it hard to mock Redis for testing
- We need to modify room.py to accept Redis service as a dependency
- Question: Should we create a Redis service interface/abstract class to make mocking easier?

4. **Additional Questions**:
- For the WebSocket tests, should we also mock the database operations?
- Should we create separate test fixtures for Redis and database mocking?
- Do we need to handle cleanup of test data between tests?

Would you like me to update the FAILING_TESTS.md with these corrected understandings? Also, please let me know if I've misunderstood any part or if you have additional clarifications to provide.

---



---

